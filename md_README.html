<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bartleby: Bartleby: a symbol renaming tool.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bartleby<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A symbol renaming toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Bartleby: a symbol renaming tool. </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Why?</li>
<li>How?<ul>
<li>Example</li>
</ul>
</li>
<li>Getting Started<ul>
<li>Using CMake</li>
<li>Using Bazel</li>
<li>Importing Bartleby in your Bazel project</li>
</ul>
</li>
<li>License</li>
</ul>
<p>This repository contains the source code for Bartleby, a library and a tool to rename symbols across several object files and static libraries.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Why? &lt;a name="why"&gt;&lt;/a&gt;</h1>
<p>If you develop a library, your end product will contain:</p>
<ul>
<li>definition for symbols that are made available to your users ("exported" functions and so on),</li>
<li>definition for symbols that you consider to be implementation details of your library and wish to hide from your users ("private" functions),</li>
<li>references to symbols that you use in your dependencies (and their definition if you link statically).</li>
</ul>
<p>Bartleby helps you ship a static library exposing only the symbols you want exposed and without polluting the namespace with the symbols of your own dependencies. It is similar to <code>objcopy --prefix-symbols=__private</code> but with "intelligent" (see the &quot;How?&quot; section below) automated selection of which symbols to prefix (for instance a reference to puts won't be renamed <code>private_puts</code> because it would lead to unresolved symbols).</p>
<p>This helps solving the diamond dependency problem: if a user of your library wants to link against OpenSSL, which also happens to be a library you link against, how do you make sure that the user remains in control of the version of OpenSSL they use without having name collisions with your own use of OpenSSL? You use Bartleby.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
How? &lt;a name="how"&gt;&lt;/a&gt;</h1>
<p>Bartleby takes a set of files as input. These can be static libraries (<code>.a</code>) or objects (<code>.o</code>). Bartleby figures out which symbols are considered private or not by iterating over all these objects (the ones directly supplied by the user, or the ones contained in the archives), and collects the visibility and the definedness of each symbols found. Using these pieces of information, a map of symbols is built as follows:</p>
<ul>
<li>If a symbol is found in several places across the input files, and at least one object actually defines it, then the symbol is marked as defined.</li>
<li>If a symbol found in an object has global visibility, then the symbol is marked as global.</li>
</ul>
<p>Finally, for each symbol marked as defined and global, Bartleby considers them as private and adds a prefix to its name, and rename all its references across all the objects. The output is a single static library that contains all the processed objects.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Example &lt;a name="how-example"&gt;&lt;/a&gt;</h2>
<p>Let's say we have the following three C files, along with their header:</p>
<ul>
<li><code>api_1.c</code>:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;external_dep.h&gt;</span></div>
<div class="line"> </div>
<div class="line">__attribute__((visibility(<span class="stringliteral">&quot;default&quot;</span>))) void my_api(<span class="keywordtype">void</span>) {</div>
<div class="line">  puts(<span class="stringliteral">&quot;my_api called, calling external dep&quot;</span>);</div>
<div class="line">  <span class="keywordtype">char</span> buf[0x41];</div>
<div class="line">  external_api(buf, <span class="keyword">sizeof</span>(buf));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> internal_impl(<span class="keywordtype">void</span>) {</div>
<div class="line">  puts(<span class="stringliteral">&quot;internal implementation, calling `my_api`&quot;</span>);</div>
<div class="line">  my_api();</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><code>api_2.c</code></li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;api_1.h&quot;</span></div>
<div class="line"> </div>
<div class="line">__attribute__((visibility(<span class="stringliteral">&quot;default&quot;</span>))) void another_api(<span class="keywordtype">void</span>) {</div>
<div class="line">  puts(<span class="stringliteral">&quot;another_api called, calling my_api&quot;</span>);</div>
<div class="line">  my_api();</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><code>external_dep.c</code></li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line">__attribute__((visibility(<span class="stringliteral">&quot;default&quot;</span>))) void external_api(<span class="keywordtype">void</span> *src, const <span class="keywordtype">size_t</span> n) {</div>
<div class="line">  puts(<span class="stringliteral">&quot;external_api called, calling external private impl&quot;</span>);</div>
<div class="line">  memset(src, 0, n);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> external_private_impl(<span class="keywordtype">void</span>) {</div>
<div class="line">  puts(<span class="stringliteral">&quot;external private implementation called&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>We compile the first two objects from our API:</p>
<div class="fragment"><div class="line">$ clang -fvisibility=hidden -c api_1.c api_2.c -isystem.</div>
<div class="line">$ file api_1.o api_2.o</div>
<div class="line">api_1.o: Mach-O 64-bit object arm64</div>
<div class="line">api_2.o: Mach-O 64-bit object arm64</div>
</div><!-- fragment --><p>Then, we create a static library out of them:</p>
<div class="fragment"><div class="line">$ ar rvs libapi.a api_1.o api_2.o</div>
</div><!-- fragment --><p>Now, let's build our simple external dependency:</p>
<div class="fragment"><div class="line">$ clang -fvisibility=hidden -c external_dep.c</div>
<div class="line">$ ar rvs libexternal.a external_dep.o</div>
</div><!-- fragment --><p><code>libapi.a</code> is the library we want to have its symbols prefixed with our custom prefix. <code>libexternal.a</code> is one of our external dependencies, and we want the user to be able to link against <code>libapi.a</code> without encountering any C symbol collisions because <code>libexternal</code> might be used in another place. We run Bartleby by giving <code>libapi.a</code> and <code>libexternal.a</code> as an input. The output will be <code>libapi_v1.1.a</code>:</p>
<div class="fragment"><div class="line">$ bartleby --if libapi.a \</div>
<div class="line">           --if libexternal.a \</div>
<div class="line">           --of libapi_v1.1.a \</div>
<div class="line">           --prefix __impl_v1.1_</div>
<div class="line">5 symbol(s) prefixed</div>
<div class="line">libapi_v1.1.a produced.</div>
</div><!-- fragment --><p>Now, we use <code>nm</code> to inspect the produced archive:</p>
<div class="fragment"><div class="line">$ nm libapi_v1.1.a</div>
<div class="line">pi_1.o:</div>
<div class="line">                U ___impl_v1.1_external_api</div>
<div class="line">0000000000000064 T ___impl_v1.1_internal_impl</div>
<div class="line">0000000000000000 T ___impl_v1.1_my_api</div>
<div class="line">                U ___stack_chk_fail</div>
<div class="line">                U ___stack_chk_guard</div>
<div class="line">                U _puts</div>
<div class="line">0000000000000084 r l_.str</div>
<div class="line">00000000000000a8 r l_.str.1</div>
<div class="line"> </div>
<div class="line">api_2.o:</div>
<div class="line">0000000000000000 T ___impl_v1.1_another_api</div>
<div class="line">                U ___impl_v1.1_my_api</div>
<div class="line">                U _puts</div>
<div class="line">0000000000000020 r l_.str</div>
<div class="line"> </div>
<div class="line">external_dep.o:</div>
<div class="line">0000000000000000 T ___impl_v1.1_external_api</div>
<div class="line">000000000000001c T ___impl_v1.1_external_private_impl</div>
<div class="line">                U _puts</div>
<div class="line">0000000000000038 r l_.str</div>
<div class="line">000000000000006b r l_.str.1</div>
</div><!-- fragment --><p>We can now see that defined symbols have been prefixed with <code>__impl_v1.1</code>. However, <code>puts</code> hasn’t been prefixed, because even if it’s a global symbol, no definition has been found in either <code>libapi.a</code> or <code>libexternal.a</code>, therefore Bartleby didn’t prefix it.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Getting Started &lt;a name="getting-started"&gt;&lt;/a&gt;</h1>
<p>Bartleby can be compiled with Bazel or CMake.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Using CMake &lt;a name="using-cmake"&gt;&lt;/a&gt;</h2>
<p>LLVM <code>&gt;=</code> 15.0 is required to build Bartleby. See <a href="https://llvm.org/docs/GettingStarted.html">Getting Started</a> to find more information about how to build LLVM, and <a href="https://releases.llvm.org/">LLVM releases</a> to find all the releases. APT packages are also available on the <a href="https://apt.llvm.org/">LLVM Debian/Ubuntu packages page</a>.</p>
<div class="fragment"><div class="line">$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DLLVM_DIR=/path/to/llvm-15/lib/cmake</div>
<div class="line">$ cmake --build build</div>
<div class="line">$ ./build/bin/bartleby</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Using Bazel &lt;a name="using-bazel"&gt;&lt;/a&gt;</h2>
<p>It is highly recommended to use <a href="https://github.com/bazelbuild/bazelisk/releases"><code>bazelisk</code></a>.</p>
<div class="fragment"><div class="line">$ bazelisk build -c opt bartleby/...</div>
<div class="line">$ ./bazel-bin/bartleby/tools/Bartleby/bartleby</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Importing Bartleby in your Bazel project &lt;a name="bazel-import"&gt;&lt;/a&gt;</h2>
<p>It is also possible to import Bartleby in an existing Bazel workspace using <a href="https://bazel.build/rules/lib/repo/http#http_archive"><code>http_archive</code></a>. One can use it as a tool, or can also use it through the [bartleby starlark rule]. See <a href="/examples/bazel"><code>examples/bazel</code></a> for more information.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
License &lt;a name="license"&gt;&lt;/a&gt;</h1>
<p>See <a href="/LICENSE"><code>LICENSE</code></a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
